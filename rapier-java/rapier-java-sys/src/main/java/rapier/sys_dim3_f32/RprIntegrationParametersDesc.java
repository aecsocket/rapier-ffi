// Generated by jextract

package rapier.sys_dim3_f32;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
/**
 * {@snippet :
 * struct RprIntegrationParametersDesc {
 *     float dt;
 *     float min_ccd_dt;
 *     float erp;
 *     float damping_ratio;
 *     float joint_erp;
 *     float joint_damping_ratio;
 *     float allowed_linear_error;
 *     float max_penetration_correction;
 *     float prediction_distance;
 *     unsigned long max_velocity_iterations;
 *     unsigned long max_velocity_friction_iterations;
 *     unsigned long max_stabilization_iterations;
 *     _Bool interleave_restitution_and_friction_resolution;
 *     unsigned long min_island_size;
 *     unsigned long max_ccd_substeps;
 * };
 * }
 */
public class RprIntegrationParametersDesc {

    static final StructLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_FLOAT$LAYOUT.withName("dt"),
        Constants$root.C_FLOAT$LAYOUT.withName("min_ccd_dt"),
        Constants$root.C_FLOAT$LAYOUT.withName("erp"),
        Constants$root.C_FLOAT$LAYOUT.withName("damping_ratio"),
        Constants$root.C_FLOAT$LAYOUT.withName("joint_erp"),
        Constants$root.C_FLOAT$LAYOUT.withName("joint_damping_ratio"),
        Constants$root.C_FLOAT$LAYOUT.withName("allowed_linear_error"),
        Constants$root.C_FLOAT$LAYOUT.withName("max_penetration_correction"),
        Constants$root.C_FLOAT$LAYOUT.withName("prediction_distance"),
        MemoryLayout.paddingLayout(32),
        Constants$root.C_LONG_LONG$LAYOUT.withName("max_velocity_iterations"),
        Constants$root.C_LONG_LONG$LAYOUT.withName("max_velocity_friction_iterations"),
        Constants$root.C_LONG_LONG$LAYOUT.withName("max_stabilization_iterations"),
        Constants$root.C_BOOL$LAYOUT.withName("interleave_restitution_and_friction_resolution"),
        MemoryLayout.paddingLayout(56),
        Constants$root.C_LONG_LONG$LAYOUT.withName("min_island_size"),
        Constants$root.C_LONG_LONG$LAYOUT.withName("max_ccd_substeps")
    ).withName("RprIntegrationParametersDesc");
    public static MemoryLayout $LAYOUT() {
        return RprIntegrationParametersDesc.$struct$LAYOUT;
    }
    static final VarHandle dt$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("dt"));
    public static VarHandle dt$VH() {
        return RprIntegrationParametersDesc.dt$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * float dt;
     * }
     */
    public static float dt$get(MemorySegment seg) {
        return (float)RprIntegrationParametersDesc.dt$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * float dt;
     * }
     */
    public static void dt$set(MemorySegment seg, float x) {
        RprIntegrationParametersDesc.dt$VH.set(seg, x);
    }
    public static float dt$get(MemorySegment seg, long index) {
        return (float)RprIntegrationParametersDesc.dt$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void dt$set(MemorySegment seg, long index, float x) {
        RprIntegrationParametersDesc.dt$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle min_ccd_dt$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("min_ccd_dt"));
    public static VarHandle min_ccd_dt$VH() {
        return RprIntegrationParametersDesc.min_ccd_dt$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * float min_ccd_dt;
     * }
     */
    public static float min_ccd_dt$get(MemorySegment seg) {
        return (float)RprIntegrationParametersDesc.min_ccd_dt$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * float min_ccd_dt;
     * }
     */
    public static void min_ccd_dt$set(MemorySegment seg, float x) {
        RprIntegrationParametersDesc.min_ccd_dt$VH.set(seg, x);
    }
    public static float min_ccd_dt$get(MemorySegment seg, long index) {
        return (float)RprIntegrationParametersDesc.min_ccd_dt$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void min_ccd_dt$set(MemorySegment seg, long index, float x) {
        RprIntegrationParametersDesc.min_ccd_dt$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle erp$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("erp"));
    public static VarHandle erp$VH() {
        return RprIntegrationParametersDesc.erp$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * float erp;
     * }
     */
    public static float erp$get(MemorySegment seg) {
        return (float)RprIntegrationParametersDesc.erp$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * float erp;
     * }
     */
    public static void erp$set(MemorySegment seg, float x) {
        RprIntegrationParametersDesc.erp$VH.set(seg, x);
    }
    public static float erp$get(MemorySegment seg, long index) {
        return (float)RprIntegrationParametersDesc.erp$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void erp$set(MemorySegment seg, long index, float x) {
        RprIntegrationParametersDesc.erp$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle damping_ratio$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("damping_ratio"));
    public static VarHandle damping_ratio$VH() {
        return RprIntegrationParametersDesc.damping_ratio$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * float damping_ratio;
     * }
     */
    public static float damping_ratio$get(MemorySegment seg) {
        return (float)RprIntegrationParametersDesc.damping_ratio$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * float damping_ratio;
     * }
     */
    public static void damping_ratio$set(MemorySegment seg, float x) {
        RprIntegrationParametersDesc.damping_ratio$VH.set(seg, x);
    }
    public static float damping_ratio$get(MemorySegment seg, long index) {
        return (float)RprIntegrationParametersDesc.damping_ratio$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void damping_ratio$set(MemorySegment seg, long index, float x) {
        RprIntegrationParametersDesc.damping_ratio$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle joint_erp$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("joint_erp"));
    public static VarHandle joint_erp$VH() {
        return RprIntegrationParametersDesc.joint_erp$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * float joint_erp;
     * }
     */
    public static float joint_erp$get(MemorySegment seg) {
        return (float)RprIntegrationParametersDesc.joint_erp$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * float joint_erp;
     * }
     */
    public static void joint_erp$set(MemorySegment seg, float x) {
        RprIntegrationParametersDesc.joint_erp$VH.set(seg, x);
    }
    public static float joint_erp$get(MemorySegment seg, long index) {
        return (float)RprIntegrationParametersDesc.joint_erp$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void joint_erp$set(MemorySegment seg, long index, float x) {
        RprIntegrationParametersDesc.joint_erp$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle joint_damping_ratio$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("joint_damping_ratio"));
    public static VarHandle joint_damping_ratio$VH() {
        return RprIntegrationParametersDesc.joint_damping_ratio$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * float joint_damping_ratio;
     * }
     */
    public static float joint_damping_ratio$get(MemorySegment seg) {
        return (float)RprIntegrationParametersDesc.joint_damping_ratio$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * float joint_damping_ratio;
     * }
     */
    public static void joint_damping_ratio$set(MemorySegment seg, float x) {
        RprIntegrationParametersDesc.joint_damping_ratio$VH.set(seg, x);
    }
    public static float joint_damping_ratio$get(MemorySegment seg, long index) {
        return (float)RprIntegrationParametersDesc.joint_damping_ratio$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void joint_damping_ratio$set(MemorySegment seg, long index, float x) {
        RprIntegrationParametersDesc.joint_damping_ratio$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle allowed_linear_error$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("allowed_linear_error"));
    public static VarHandle allowed_linear_error$VH() {
        return RprIntegrationParametersDesc.allowed_linear_error$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * float allowed_linear_error;
     * }
     */
    public static float allowed_linear_error$get(MemorySegment seg) {
        return (float)RprIntegrationParametersDesc.allowed_linear_error$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * float allowed_linear_error;
     * }
     */
    public static void allowed_linear_error$set(MemorySegment seg, float x) {
        RprIntegrationParametersDesc.allowed_linear_error$VH.set(seg, x);
    }
    public static float allowed_linear_error$get(MemorySegment seg, long index) {
        return (float)RprIntegrationParametersDesc.allowed_linear_error$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void allowed_linear_error$set(MemorySegment seg, long index, float x) {
        RprIntegrationParametersDesc.allowed_linear_error$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle max_penetration_correction$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("max_penetration_correction"));
    public static VarHandle max_penetration_correction$VH() {
        return RprIntegrationParametersDesc.max_penetration_correction$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * float max_penetration_correction;
     * }
     */
    public static float max_penetration_correction$get(MemorySegment seg) {
        return (float)RprIntegrationParametersDesc.max_penetration_correction$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * float max_penetration_correction;
     * }
     */
    public static void max_penetration_correction$set(MemorySegment seg, float x) {
        RprIntegrationParametersDesc.max_penetration_correction$VH.set(seg, x);
    }
    public static float max_penetration_correction$get(MemorySegment seg, long index) {
        return (float)RprIntegrationParametersDesc.max_penetration_correction$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void max_penetration_correction$set(MemorySegment seg, long index, float x) {
        RprIntegrationParametersDesc.max_penetration_correction$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle prediction_distance$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("prediction_distance"));
    public static VarHandle prediction_distance$VH() {
        return RprIntegrationParametersDesc.prediction_distance$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * float prediction_distance;
     * }
     */
    public static float prediction_distance$get(MemorySegment seg) {
        return (float)RprIntegrationParametersDesc.prediction_distance$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * float prediction_distance;
     * }
     */
    public static void prediction_distance$set(MemorySegment seg, float x) {
        RprIntegrationParametersDesc.prediction_distance$VH.set(seg, x);
    }
    public static float prediction_distance$get(MemorySegment seg, long index) {
        return (float)RprIntegrationParametersDesc.prediction_distance$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void prediction_distance$set(MemorySegment seg, long index, float x) {
        RprIntegrationParametersDesc.prediction_distance$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle max_velocity_iterations$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("max_velocity_iterations"));
    public static VarHandle max_velocity_iterations$VH() {
        return RprIntegrationParametersDesc.max_velocity_iterations$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * unsigned long max_velocity_iterations;
     * }
     */
    public static long max_velocity_iterations$get(MemorySegment seg) {
        return (long)RprIntegrationParametersDesc.max_velocity_iterations$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * unsigned long max_velocity_iterations;
     * }
     */
    public static void max_velocity_iterations$set(MemorySegment seg, long x) {
        RprIntegrationParametersDesc.max_velocity_iterations$VH.set(seg, x);
    }
    public static long max_velocity_iterations$get(MemorySegment seg, long index) {
        return (long)RprIntegrationParametersDesc.max_velocity_iterations$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void max_velocity_iterations$set(MemorySegment seg, long index, long x) {
        RprIntegrationParametersDesc.max_velocity_iterations$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle max_velocity_friction_iterations$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("max_velocity_friction_iterations"));
    public static VarHandle max_velocity_friction_iterations$VH() {
        return RprIntegrationParametersDesc.max_velocity_friction_iterations$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * unsigned long max_velocity_friction_iterations;
     * }
     */
    public static long max_velocity_friction_iterations$get(MemorySegment seg) {
        return (long)RprIntegrationParametersDesc.max_velocity_friction_iterations$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * unsigned long max_velocity_friction_iterations;
     * }
     */
    public static void max_velocity_friction_iterations$set(MemorySegment seg, long x) {
        RprIntegrationParametersDesc.max_velocity_friction_iterations$VH.set(seg, x);
    }
    public static long max_velocity_friction_iterations$get(MemorySegment seg, long index) {
        return (long)RprIntegrationParametersDesc.max_velocity_friction_iterations$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void max_velocity_friction_iterations$set(MemorySegment seg, long index, long x) {
        RprIntegrationParametersDesc.max_velocity_friction_iterations$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle max_stabilization_iterations$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("max_stabilization_iterations"));
    public static VarHandle max_stabilization_iterations$VH() {
        return RprIntegrationParametersDesc.max_stabilization_iterations$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * unsigned long max_stabilization_iterations;
     * }
     */
    public static long max_stabilization_iterations$get(MemorySegment seg) {
        return (long)RprIntegrationParametersDesc.max_stabilization_iterations$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * unsigned long max_stabilization_iterations;
     * }
     */
    public static void max_stabilization_iterations$set(MemorySegment seg, long x) {
        RprIntegrationParametersDesc.max_stabilization_iterations$VH.set(seg, x);
    }
    public static long max_stabilization_iterations$get(MemorySegment seg, long index) {
        return (long)RprIntegrationParametersDesc.max_stabilization_iterations$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void max_stabilization_iterations$set(MemorySegment seg, long index, long x) {
        RprIntegrationParametersDesc.max_stabilization_iterations$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle interleave_restitution_and_friction_resolution$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("interleave_restitution_and_friction_resolution"));
    public static VarHandle interleave_restitution_and_friction_resolution$VH() {
        return RprIntegrationParametersDesc.interleave_restitution_and_friction_resolution$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * _Bool interleave_restitution_and_friction_resolution;
     * }
     */
    public static boolean interleave_restitution_and_friction_resolution$get(MemorySegment seg) {
        return (boolean)RprIntegrationParametersDesc.interleave_restitution_and_friction_resolution$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * _Bool interleave_restitution_and_friction_resolution;
     * }
     */
    public static void interleave_restitution_and_friction_resolution$set(MemorySegment seg, boolean x) {
        RprIntegrationParametersDesc.interleave_restitution_and_friction_resolution$VH.set(seg, x);
    }
    public static boolean interleave_restitution_and_friction_resolution$get(MemorySegment seg, long index) {
        return (boolean)RprIntegrationParametersDesc.interleave_restitution_and_friction_resolution$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void interleave_restitution_and_friction_resolution$set(MemorySegment seg, long index, boolean x) {
        RprIntegrationParametersDesc.interleave_restitution_and_friction_resolution$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle min_island_size$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("min_island_size"));
    public static VarHandle min_island_size$VH() {
        return RprIntegrationParametersDesc.min_island_size$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * unsigned long min_island_size;
     * }
     */
    public static long min_island_size$get(MemorySegment seg) {
        return (long)RprIntegrationParametersDesc.min_island_size$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * unsigned long min_island_size;
     * }
     */
    public static void min_island_size$set(MemorySegment seg, long x) {
        RprIntegrationParametersDesc.min_island_size$VH.set(seg, x);
    }
    public static long min_island_size$get(MemorySegment seg, long index) {
        return (long)RprIntegrationParametersDesc.min_island_size$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void min_island_size$set(MemorySegment seg, long index, long x) {
        RprIntegrationParametersDesc.min_island_size$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle max_ccd_substeps$VH = $struct$LAYOUT.varHandle(MemoryLayout.PathElement.groupElement("max_ccd_substeps"));
    public static VarHandle max_ccd_substeps$VH() {
        return RprIntegrationParametersDesc.max_ccd_substeps$VH;
    }
    /**
     * Getter for field:
     * {@snippet :
     * unsigned long max_ccd_substeps;
     * }
     */
    public static long max_ccd_substeps$get(MemorySegment seg) {
        return (long)RprIntegrationParametersDesc.max_ccd_substeps$VH.get(seg);
    }
    /**
     * Setter for field:
     * {@snippet :
     * unsigned long max_ccd_substeps;
     * }
     */
    public static void max_ccd_substeps$set(MemorySegment seg, long x) {
        RprIntegrationParametersDesc.max_ccd_substeps$VH.set(seg, x);
    }
    public static long max_ccd_substeps$get(MemorySegment seg, long index) {
        return (long)RprIntegrationParametersDesc.max_ccd_substeps$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void max_ccd_substeps$set(MemorySegment seg, long index, long x) {
        RprIntegrationParametersDesc.max_ccd_substeps$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(long len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemorySegment addr, SegmentScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


